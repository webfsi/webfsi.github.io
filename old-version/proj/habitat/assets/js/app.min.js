/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/scripts/app.js":
/*!****************************!*\
  !*** ./src/scripts/app.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _inner_team_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inner/team.js */ \"./src/scripts/inner/team.js\");\n/* harmony import */ var _inner_cursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inner/cursor.js */ \"./src/scripts/inner/cursor.js\");\n/* harmony import */ var _inner_preloader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inner/preloader.js */ \"./src/scripts/inner/preloader.js\");\n/* harmony import */ var _inner_cookies_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inner/cookies.js */ \"./src/scripts/inner/cookies.js\");\n\n\n\n // import btn from \"./inner/btn.js\";\n// preloader();\n// if (!sessionStorage.isVisited) {\n//   console.log(1);\n// } else {\n//   console.log(2);\n// }\n// if (!sessionStorage.isVisited) {\n//   sessionStorage.isVisited = 'true'\n//   // $(window).load(/* ... */)\n//   console.log(3);\n// } else {\n//   console.log(4);\n// }\n\n(0,_inner_cookies_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(); // preloader\n\nvar valueSession = false;\n\nif (sessionStorage.getItem(\"autosave\")) {\n  valueSession = sessionStorage.getItem(\"autosave\");\n}\n\nif (valueSession === false) {\n  (0,_inner_preloader_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n  document.body.classList.add('first-load');\n  window.addEventListener('load', function () {\n    if (document.querySelector('.wrapper').classList.contains('wrapper_load')) {\n      setTimeout(function () {\n        document.querySelector('.wrapper').classList.remove('wrapper_load');\n      }, 5500);\n    }\n  });\n  valueSession = true;\n  sessionStorage.setItem(\"autosave\", valueSession);\n} else {\n  document.querySelector('[data-loader]').classList.add('hidden');\n  document.querySelector('.wrapper').classList.remove('wrapper_load');\n} // end preloader\n\n\nwindow.addEventListener('load', function () {\n  // $(document).ready(function(){\n  // console.log('Congrats, ES6!!!');\n  // var field = document.getElementById(\"field\");\n  // Проверяем наличие значения 'autosave'\n  // (это может произойти только если страница будет случайно обновлена)\n  // if (sessionStorage.getItem(\"autosave\", \"value\")) {\n  //   // Восстанавливаем содержимое текстового поля\n  //   // field.value = sessionStorage.getItem(\"autosave\");\n  //   preloader();\n  //   sessionstor = \"ssss\",\n  //   sessionStorage.setItem(\"autosave\", sessionstor)\n  //   console.log(sessionStorage.getItem(\"autosave\"));\n  //   // sessionstor === true;\n  // }\n  // Отслеживаем все изменения в текстовом поле\n  // field.addEventListener(\"change\", function() {\n  //   // И сохраняем их в объект session storage\n  //   sessionStorage.setItem(\"autosave\", true)\n  // });\n  // if('sessionStorage' in window && window.sessionStorage !== null) {\n  //   document.getElementById('result').innerText = \"Storage supported\";\n  // } else {\n  //   document.getElementById('result').innerText = \"Storage not supported\";\n  // }\n  // sessionStorage.setItem('autosave', 'value');\n  // var data = sessionStorage.getItem('key');\n  // if (sessionStorage.getItem(\"autosave\")) {\n  //   console.log(\"öbject\");\n  // }\n  // console.log(data);\n  // emuljator multi page\n  $(\"[data-btn-home]\").click(function () {\n    $(\".wrapper\").load(\"./_home-inner.php\", function () {\n      $(this).unwrap();\n      (0,_inner_team_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n      $(\"body\").addClass('page-home');\n      $(\"body\").removeClass('page-contacts');\n      $(\"body\").removeClass('page-contacts_anim-hidden');\n    });\n  }); // end emuljator multi page\n\n  (0,_inner_cursor_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n  (0,_inner_team_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // splitting();\n  // btn();\n  // //  validate form\n  // const validateOption = {\n  //   rules: {\n  //     text: \"required\",\n  //     text2: \"required\",\n  //     text3: \"required\",\n  //     text4: \"required\",\n  //     name: \"required\",\n  //     name2: \"required\",\n  //     name3: \"required\",\n  //     name4: \"required\",\n  //     search: \"required\",\n  //     select: {\n  //       minlength: 1,\n  //       required: true\n  //     },\n  //     select2: {\n  //       minlength: 1,\n  //       required: true\n  //     },\n  //     mail: {\n  //       required: true,\n  //       email: true\n  //     },\n  //     url: {\n  //       required: true,\n  //       url: true\n  //     },\n  //     phone: {\n  //       required: true\n  //     },\n  //     password: {\n  //       required: true,\n  //       minlength: 5\n  //     },\n  //     password_confirm: {\n  //         required: true,\n  //         minlength: 5,\n  //         equalTo: \"#password\"\n  //     }\n  //   }\n  // }\n  // const validateForm = document.querySelectorAll('[data-validate]')\n  // validateForm.forEach(element => {\n  //   $(\"[data-validate]\").validate({\n  //     messages: {\n  //       email: {\n  //         required: 'Oooops, that email address looks a bit weird',\n  //         equalTo: 'sadasdas',\n  //       }\n  //     },\n  //     submitHandler: function(form) {\n  //       // form.submit();\n  //       $(\".contact-section-wrapp\").addClass('send-form')\n  //       // $(form).submit();\n  //     }\n  //   });\n  //   $('.contact-end__tt a').hover(\n  //     function() {\n  //       $('.contact-end__tt').addClass('hover')\n  //     }, function() {\n  //       $('.contact-end__tt').removeClass('hover')\n  //     }\n  //   )\n  // });\n  //form elements\n  // jcf.setOptions('File', {\n  //   buttonText: 'Project details',\n  //   placeholderText: 'Project description'\n  // });\n  // jcf.setOptions('Select', {\n  //   wrapNative: false,\n  //   multipleCompactStyle: true,\n  //   maxVisibleItems: 6,\n  //   fakeDropInBody: false,\n  //   useCustomScroll: false\n  // });\n  // jcf.replaceAll();\n  // const inputchenge1 = document.querySelectorAll('.file')\n  // inputchenge1.forEach(element => {\n  //   $(\".file\").aksFileUpload({\n  //     input:\"#aksfileupload\",\n  //     fileUpload: \"#uploadfile\",\n  //     maxSize: \"1 GB\",\n  //     multiple: false,\n  //   });\n  // \tconst inputchenge = element.querySelector('.file input')\n  // \tinputchenge.addEventListener('change', function() {\n  // \t\telement.parentElement.classList.toggle('active');\n  // \t})\n  // });\n});\n\n//# sourceURL=webpack://webpack-workflow/./src/scripts/app.js?");

/***/ }),

/***/ "./src/scripts/inner/cookies.js":
/*!**************************************!*\
  !*** ./src/scripts/inner/cookies.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {\n  var cookiesVar = false;\n\n  if (sessionStorage.getItem(\"cookies\")) {\n    cookiesVar = sessionStorage.getItem(\"cookies\");\n  }\n\n  if (cookiesVar === false) {\n    $(\"[data-cookies]\").each(function (i, el) {\n      console.log($(this).find('.btn'));\n      var s = $(this).find('.btn');\n      s.click(function () {\n        $(el).addClass('active');\n        setTimeout(function () {\n          $(el).addClass('hidden');\n          cookiesVar = true;\n          sessionStorage.setItem(\"cookies\", cookiesVar);\n        }, 600);\n      });\n    });\n  } else {\n    $(\"[data-cookies]\").addClass('hidden');\n  }\n});\n\n//# sourceURL=webpack://webpack-workflow/./src/scripts/inner/cookies.js?");

/***/ }),

/***/ "./src/scripts/inner/cursor.js":
/*!*************************************!*\
  !*** ./src/scripts/inner/cursor.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {\n  // marker hover\n  if (window.matchMedia(\"(min-width: 1054px)\").matches) {\n    var curs = document.querySelector('.cursor');\n\n    if (!curs) {\n      return;\n    }\n\n    document.addEventListener('mousemove', function (e) {\n      var x = e.pageX;\n      var y = e.pageY;\n      curs.style.left = x - 30 + \"px\";\n      curs.style.top = y - 30 + \"px\";\n      curs.classList.add('active');\n      curs.classList.remove('hidden');\n    });\n    document.addEventListener('mouseleave', function (e) {\n      var x = e.pageX;\n      var y = e.pageY;\n      curs.style.left = x - 30 + \"px\";\n      curs.style.top = y - 30 + \"px\";\n      curs.classList.add('hidden');\n      curs.classList.remove('active');\n    });\n  } // document.querySelector('[data-loader]').classList.add('ready')\n  // const arrImg = document.querySelector('[data-img-random]');\n  // const arrImgData = arrImg.dataset.imgRandom;\n  // let arr = arrImgData.split(' ', 20);\n  // // console.log(splits);\n  // // const arr = ['assets/img/load1.jpg', 'assets/img/load2.jpg', 'assets/img/load3.jpg', 'assets/img/load4.jpg', 'assets/img/load5.jpg'];\n  // console.log(arr);\n  // const random = arr[Math.floor(Math.random() * arr.length)];\n  // // console.log(random); // 👉️ three\n  // // console.log(arr[Math.floor(Math.random() * arr.length)], arr[Math.floor(Math.random() * arr.length)], arr[Math.floor(Math.random() * arr.length)]);\n  // // var getMeRandomElements = function() {\n  // // }\n  // var result = [];\n  // var array = [];\n  // for (var i = 0; i < 3; i++) {\n  //     result.push(arr.splice(arr.length * Math.random() | 0, 1)[0]);\n  // }\n  // // console.log(result[2]);\n  // const itemsLoader = document.querySelectorAll('[data-loader] .loader__item img')\n  // for (let i = 0; i < itemsLoader.length; i++) {\n  //   const element = itemsLoader[i];\n  //   // console.log(element);\n  //   itemsLoader[i].src=result[i];\n  // }\n  //   console.log(Math.floor(4.99)); // 👉️ 4\n  //   console.log(Math.floor(4.01)); // 👉️ 4\n  //   console.log(Math.floor(4)); // 👉️ 4\n  //   console.log(Math.random() * arr.length); // 👉️ 1.335...\n  // console.log(Math.random() * arr.length); // 👉️ 2.643...\n  // console.log(Math.random() * arr.length); // 👉️ 0.393...\n  // console.log(Math.random() * arr.length); // 👉️ 4.247...\n  // let header = document.getElementById('header');\n  // let oldScrollTopPosition = 1;\n  // let scrollTopPosition = 1;\n  // window.onscroll = () => {\n  // \tscrollTopPosition = document.documentElement.scrollTop;\n  // \tif (scrollTopPosition < oldScrollTopPosition) {\n  // \t\theader.classList.add('header--fixed')\n  // \t\theader.classList.remove('header--hide')\n  // \t} else if (scrollTopPosition > oldScrollTopPosition) {\n  // \t\theader.classList.remove('header--fixed')\n  // \t\theader.classList.add('header--hide')\n  // \t}\n  // \toldScrollTopPosition = scrollTopPosition;\n  // \tif (scrollTopPosition === 0) {\n  // \t\theader.classList.remove('header--fixed')\n  // \t\theader.classList.remove('header--hide')\n  // \t}\n  // }\n\n});\n\n//# sourceURL=webpack://webpack-workflow/./src/scripts/inner/cursor.js?");

/***/ }),

/***/ "./src/scripts/inner/preloader.js":
/*!****************************************!*\
  !*** ./src/scripts/inner/preloader.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {\n  // Preloader\n  var loader = document.querySelectorAll('[data-loader]');\n  loader.forEach(function (element) {\n    var arrImg = document.querySelector('[data-img-random]');\n    var arrImgData = arrImg.dataset.imgRandom;\n    var arr = arrImgData.split(', ', 20);\n    var result = [];\n\n    for (var i = 0; i < 3; i++) {\n      result.push(arr.splice(arr.length * Math.random() | 0, 1)[0]);\n    }\n\n    var itemsLoader = document.querySelectorAll('[data-loader] .loader__item img');\n\n    for (var _i = 0; _i < itemsLoader.length; _i++) {\n      var _element = itemsLoader[_i];\n      _element.src = result[_i];\n    }\n\n    window.addEventListener('load', function () {\n      document.querySelector('[data-loader]').classList.add('ready');\n      setTimeout(function () {\n        document.querySelector('[data-loader]').classList.add('hidden');\n      }, 4000);\n    });\n  }); // Preloader end\n});\n\n//# sourceURL=webpack://webpack-workflow/./src/scripts/inner/preloader.js?");

/***/ }),

/***/ "./src/scripts/inner/team.js":
/*!***********************************!*\
  !*** ./src/scripts/inner/team.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var split_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! split-type */ \"./node_modules/split-type/dist/index.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function () {\n  gsap.registerPlugin(ScrollTrigger);\n  var wrapper = document.querySelector('.wrapper'); // let scroller;\n  //  validate form\n\n  var validateOption = {\n    rules: {\n      text: \"required\",\n      text2: \"required\",\n      text3: \"required\",\n      text4: \"required\",\n      name: \"required\",\n      name2: \"required\",\n      name3: \"required\",\n      name4: \"required\",\n      search: \"required\",\n      select: {\n        minlength: 1,\n        required: true\n      },\n      select2: {\n        minlength: 1,\n        required: true\n      },\n      mail: {\n        required: true,\n        email: true\n      },\n      url: {\n        required: true,\n        url: true\n      },\n      phone: {\n        required: true\n      },\n      password: {\n        required: true,\n        minlength: 5\n      },\n      password_confirm: {\n        required: true,\n        minlength: 5,\n        equalTo: \"#password\"\n      }\n    }\n  };\n\n  function fileInputMy() {\n    var inputchenge1 = document.querySelectorAll('.file');\n    inputchenge1.forEach(function (element) {\n      $(\".file\").aksFileUpload({\n        input: \"#aksfileupload\",\n        fileUpload: \"#uploadfile\",\n        maxSize: \"1 GB\",\n        multiple: false\n      });\n      var inputchenge = element.querySelector('.file input');\n      inputchenge.addEventListener('change', function () {\n        element.parentElement.classList.toggle('active');\n      });\n    });\n  }\n\n  ScrollTrigger.matchMedia({\n    '(min-width: 1054px)': function minWidth1054px() {\n      var scroller = new LocomotiveScroll({\n        el: document.querySelector('[data-scroll-container]'),\n        smooth: true,\n        lerp: 0.07,\n        // Linear Interpolation, 0 > 1 // Try 0.01\n        // multiplier: 1, // Effect Multiplier\n        reloadOnContextChange: true,\n        // touchMultiplier: 2,\n        smoothMobile: true,\n        // smartphone: {\n        //     smooth: !0,\n        // \t\tlerp: 0.1,\n        // \t\tmultiplier: 1,\n        // \t\tinertia: 0,\n        //     breakpoint: 767\n        // },\n        // tablet: {\n        //     smooth: !1,\n        // \t\tinertia: 0,\n        // \t\tmultiplier: 1,\n        // \t\tlerp: 0.1,\n        //     breakpoint: 1024\n        // },\n        // smartphone: {\n        //     smooth: true,\n        // \t\tlerp: 0.1,\n        // \t\tmultiplier: 1,\n        // \t\tinertia: 0,\n        //     breakpoint: 767\n        // },\n        mobile: {\n          smooth: true,\n          lerp: 0.1,\n          multiplier: 1,\n          inertia: 0,\n          breakpoint: 767\n        },\n        tablet: {\n          smooth: true,\n          inertia: 0,\n          multiplier: 1,\n          lerp: 0.1,\n          breakpoint: 1024\n        }\n      });\n      scroller.on('scroll', ScrollTrigger.update);\n      ScrollTrigger.scrollerProxy(wrapper, {\n        scrollTop: function scrollTop(value) {\n          return arguments.length ? scroller.scrollTo(value, 0, 0) : scroller.scroll.instance.scroll.y;\n        },\n        scrollLeft: function scrollLeft(value) {\n          return arguments.length ? scroller.scrollTo(value, 0, 0) : scroller.scroll.instance.scroll.x;\n        },\n        getBoundingClientRect: function getBoundingClientRect() {\n          return {\n            left: 0,\n            top: 0,\n            width: window.innerWidth,\n            height: window.innerHeight\n          };\n        } // pinType: wrapper.style.transform ? \"transform\" : \"fixed\"\n\n      });\n      ScrollTrigger.defaults({\n        scroller: wrapper\n      }); // marker hover\n\n      if (window.matchMedia(\"(min-width: 1054px)\").matches) {\n        var update = function update(e) {\n          // var x = e.clientX || e.touches[0].clientX\n          // var y = e.clientY || e.touches[0].clientY\n          var box = document.querySelectorAll('.mark-boxes');\n          box.forEach(function (element) {\n            var x = e.pageX; // let y = e.pageY - document.body.scrollTop - document.documentElement.scrollTop - scroller.scroll.instance.scroll.y;\n            // let y = e.pageY - scroller.scroll.instance.scroll.y;\n\n            var y = e.pageY - (element.offsetTop - scroller.scroll.instance.scroll.y);\n            document.documentElement.style.setProperty('--cursorX', x + 'px');\n            document.documentElement.style.setProperty('--cursorY', y + 'px');\n          });\n        };\n\n        document.addEventListener('mousemove', update);\n        document.addEventListener('touchmove', update);\n      } // end marker hover\n\n      /**\n      * demo.js\n      * http://www.codrops.com\n      *\n      * Licensed under the MIT license.\n      * http://www.opensource.org/licenses/mit-license.php\n      * \n      * Copyright 2018, Codrops\n      * http://www.codrops.com\n      */\n\n\n      {\n        // var bodyRect = document.body.getBoundingClientRect(),\n        // elemRect = element.getBoundingClientRect(),\n        // offset   = elemRect.top - bodyRect.top;\n        var getOffset = function getOffset(el) {\n          el = el.getBoundingClientRect();\n          return {\n            left: el.left + window.scrollX,\n            top: el.top + window.scrollY\n          };\n        }; // const txtBL = document.querySelectorAll('.txt-hover-box');\n        // txtBL.forEach(elm => {\n        // \t\telm.addEventListener('mousemove', function(e) {\n        // \t\t\t\t// getOffset(elm)\n        // \t\t\t\t// console.log(getOffset(elm));\n        // \t\t\t\t// var rect = elm.getBoundingClientRect();\n        // \t\t\t\t// console.log( rect.x, rect.y, rect.width, rect.height);\n        // \t\t\t\t// let x = e.pageX,\n        // \t\t\t\t// \t\ty = e.pageY;\n        // \t\t\t\t// console.log(`${x - elm.offsetLeft}:${y+scroller.scroll.instance.scroll.y-elm.offsetTop}`);\n        // \t\t\t\t// console.log(e.pageY);\n        // \t\t\t\t// console.log(elm.offsetTop);\n        // \t\t\t\tconsole.log(scroller.scroll.instance.scroll.y);\n        // \t\t})\n        // });\n        // alert('Element is ' + offset + ' vertical pixels from <body>');\n        // console.log('Element is ' + offset + ' vertical pixels from <body>');\n\n\n        var mapNumber = function mapNumber(X, A, B, C, D) {\n          return (X - A) * (D - C) / (B - A) + C;\n        }; // from http://www.quirksmode.org/js/events_properties.html#position\n\n\n        var getMousePos = function getMousePos(e) {\n          var posx = 0;\n          var posy = 0;\n          if (!e) e = window.event;\n\n          if (e.pageX || e.pageY) {\n            posx = e.pageX;\n            posy = e.pageY;\n          } else if (e.clientX || e.clientY) {\n            posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n          }\n\n          return {\n            x: posx,\n            y: posy\n          };\n        }; // Generate a random float.\n\n\n        var getRandomFloat = function getRandomFloat(min, max) {\n          return (Math.random() * (max - min) + min).toFixed(2);\n        };\n        /**\n         * One class per effect. \n         * Lots of code is repeated, so that single effects can be easily used. \n         */\n        // Effect 3\n\n\n        var HoverImgFx3 = /*#__PURE__*/function () {\n          function HoverImgFx3(el) {\n            _classCallCheck(this, HoverImgFx3);\n\n            this.DOM = {\n              el: el\n            };\n            this.DOM.reveal = document.createElement('div');\n            this.DOM.reveal.className = 'hover-reveal';\n            this.DOM.reveal.style.overflow = 'hidden';\n            this.DOM.reveal.innerHTML = \"<div class=\\\"hover-reveal__inner\\\"><div class=\\\"hover-reveal__img\\\" style=\\\"background-image:url(\".concat(this.DOM.el.dataset.img, \")\\\"></div></div>\");\n            this.DOM.el.appendChild(this.DOM.reveal);\n            this.DOM.revealInner = this.DOM.reveal.querySelector('.hover-reveal__inner');\n            this.DOM.revealInner.style.overflow = 'hidden';\n            this.DOM.revealImg = this.DOM.revealInner.querySelector('.hover-reveal__img'); //   charming(this.DOM.el);\n            //   this.DOM.letters = [...this.DOM.el.querySelectorAll('span')];\n\n            this.initEvents();\n          }\n\n          _createClass(HoverImgFx3, [{\n            key: \"initEvents\",\n            value: function initEvents() {\n              var _this = this;\n\n              this.positionElement = function (ev) {\n                var mousePos = getMousePos(ev);\n                var docScrolls = {\n                  left: document.body.scrollLeft + document.documentElement.scrollLeft,\n                  top: document.body.scrollTop + document.documentElement.scrollTop - scroller.scroll.instance.scroll.y\n                };\n                _this.DOM.reveal.style.top = \"\".concat(mousePos.y + 20 - docScrolls.top, \"px\");\n                _this.DOM.reveal.style.left = \"\".concat(mousePos.x + 20 - docScrolls.left, \"px\");\n              };\n\n              this.mouseenterFn = function (ev) {\n                _this.positionElement(ev);\n\n                _this.showImage(); //   this.animateLetters();\n\n              };\n\n              this.mousemoveFn = function (ev) {\n                return requestAnimationFrame(function () {\n                  _this.positionElement(ev);\n                });\n              };\n\n              this.mouseleaveFn = function () {\n                _this.hideImage();\n              };\n\n              this.DOM.el.addEventListener('mouseenter', this.mouseenterFn);\n              this.DOM.el.addEventListener('mousemove', this.mousemoveFn);\n              this.DOM.el.addEventListener('mouseleave', this.mouseleaveFn);\n            }\n          }, {\n            key: \"showImage\",\n            value: function showImage() {\n              var _this2 = this;\n\n              TweenMax.killTweensOf(this.DOM.revealInner);\n              TweenMax.killTweensOf(this.DOM.revealImg);\n              this.tl = new TimelineMax({\n                onStart: function onStart() {\n                  _this2.DOM.reveal.style.opacity = 1;\n                  TweenMax.set(_this2.DOM.el, {\n                    zIndex: 1000\n                  });\n                }\n              }).add('begin').set([this.DOM.revealInner, this.DOM.revealImg], {\n                transformOrigin: '50% 100%'\n              }).add(new TweenMax(this.DOM.revealInner, 0.4, {\n                ease: Expo.easeOut,\n                startAt: {\n                  x: '50%',\n                  y: '120%',\n                  rotation: 50\n                },\n                x: '0%',\n                y: '0%',\n                rotation: 0\n              }), 'begin').add(new TweenMax(this.DOM.revealImg, 0.4, {\n                ease: Expo.easeOut,\n                startAt: {\n                  x: '-50%',\n                  y: '-120%',\n                  rotation: -50\n                },\n                x: '0%',\n                y: '0%',\n                rotation: 0\n              }), 'begin').add(new TweenMax(this.DOM.revealImg, 0.7, {\n                ease: Expo.easeOut,\n                startAt: {\n                  scale: 2\n                },\n                scale: 1\n              }), 'begin');\n            }\n          }, {\n            key: \"hideImage\",\n            value: function hideImage() {\n              var _this3 = this;\n\n              TweenMax.killTweensOf(this.DOM.revealInner);\n              TweenMax.killTweensOf(this.DOM.revealImg);\n              this.tl = new TimelineMax({\n                onStart: function onStart() {\n                  TweenMax.set(_this3.DOM.el, {\n                    zIndex: 999\n                  });\n                },\n                onComplete: function onComplete() {\n                  TweenMax.set(_this3.DOM.el, {\n                    zIndex: ''\n                  });\n                  TweenMax.set(_this3.DOM.reveal, {\n                    opacity: 0\n                  });\n                }\n              }).add('begin').add(new TweenMax(this.DOM.revealInner, 0.6, {\n                ease: Expo.easeOut,\n                y: '-120%',\n                rotation: -5\n              }), 'begin').add(new TweenMax(this.DOM.revealImg, 0.6, {\n                ease: Expo.easeOut,\n                y: '120%',\n                rotation: 5,\n                scale: 1.2\n              }), 'begin');\n            }\n          }, {\n            key: \"animateLetters\",\n            value: function animateLetters() {\n              TweenMax.killTweensOf(this.DOM.letters);\n              TweenMax.set(this.DOM.letters, {\n                opacity: 0\n              });\n              TweenMax.staggerTo(this.DOM.letters, 0.2, {\n                ease: Expo.easeOut,\n                startAt: {\n                  x: '100%'\n                },\n                x: '0%',\n                opacity: 1\n              }, 0.03);\n            }\n          }]);\n\n          return HoverImgFx3;\n        }();\n\n        _toConsumableArray(document.querySelectorAll('[data-fx=\"3\"] > .txt-hover-img, .txt-hover-img[data-fx=\"3\"]')).forEach(function (link) {\n          return new HoverImgFx3(link);\n        }); // Demo purspose only: Preload all the images in the page..\n        //   const contentel = document.querySelector('.content');\n        //   [...document.querySelectorAll('.block__title, .block__link, .content__text-link')].forEach((el) => {\n        //       const imgsArr = el.dataset.img.split(',');\n        //       for (let i = 0, len = imgsArr.length; i <= len-1; ++i ) {\n        //           const imgel = document.createElement('img');\n        //           imgel.style.visibility = 'hidden';\n        //           imgel.style.width = 0;\n        //           imgel.src = imgsArr[i];\n        //           imgel.className = 'preload';\n        //           contentel.appendChild(imgel);\n        //       }\n        //   });\n        //   imagesLoaded(document.querySelectorAll('.preload'), () => document.body.classList.remove('loading'));\n\n      } //accordion\n\n      $(\".acc-bl__cap\").click(function () {\n        if ($(this).parent().hasClass(\"active\")) {\n          $(this).parent().removeClass(\"active\").find(\".acc-bl__body\").slideUp();\n        } else {\n          $(\".acc-bl\").removeClass(\"active\").find(\".acc-bl__body\").slideUp();\n          $(this).parent().addClass(\"active\").find(\".acc-bl__body\").slideDown();\n        }\n\n        setTimeout(function () {\n          //REFRESH\n          ScrollTrigger.addEventListener('refresh', function () {\n            return scroller.update();\n          }); // ScrollTrigger.refresh();\n          // scroller.update();\n\n          ScrollTrigger.refresh();\n        }, 500);\n      }); // $(\"[data-refresh]\").click(function(){\n      // \tscroller.update();\n      // \tScrollTrigger.addEventListener('refresh', () => scroller.update())\n      // \t// ScrollTrigger.refresh();\n      // \tScrollTrigger.refresh();\n      // })\n\n      function validates() {\n        var validateForm = document.querySelectorAll('[data-validate]');\n        validateForm.forEach(function (element) {\n          $(\"[data-validate]\").validate({\n            messages: {\n              email: {\n                required: 'Oooops, that email address looks a bit weird',\n                equalTo: 'sadasdas'\n              }\n            },\n            submitHandler: function submitHandler(form) {\n              // form.submit();\n              $(\".contact-section-wrapp\").addClass('send-form');\n              scroller.update(); // $(form).submit();\n            }\n          });\n          $('.contact-end__tt a').hover(function () {\n            $('.contact-end__tt').addClass('hover');\n          }, function () {\n            $('.contact-end__tt').removeClass('hover');\n          });\n        });\n      } //REFRESH\n\n\n      ScrollTrigger.addEventListener('refresh', function () {\n        return scroller.update();\n      });\n      ScrollTrigger.refresh(); // Listen for orientation changes\n\n      window.addEventListener(\"resize\", function () {\n        ScrollTrigger.addEventListener('refresh', function () {\n          return scroller.update();\n        });\n        ScrollTrigger.refresh();\n      }, false); // multi page emuljator\n\n      $(\"[data-load-content]\").click(function () {\n        $(\".wrapper\").load(\"./_contacts.php\", function () {\n          $(this).unwrap();\n          validates();\n          fileInputMy();\n          $(\"body\").addClass('page-contacts');\n          $(\"body\").removeClass('page-home');\n          $(\"body\").removeClass('first-load');\n          ScrollTrigger.addEventListener('refresh', function () {\n            return scroller.update();\n          });\n          ScrollTrigger.refresh();\n          setTimeout(function () {\n            $(\"body\").addClass('page-contacts_anim-hidden');\n          }, 2000);\n        });\n      }); // end multi page emuljator\n    },\n    //MAX WIDTH 1053\n    '(max-width: 1053px)': function maxWidth1053px() {\n      // multi page emuljator\n      $(\"[data-load-content]\").click(function () {\n        $(\".wrapper\").load(\"./_contacts.php\", function () {\n          $(this).unwrap();\n          validateMob();\n          fileInputMy();\n          $(\"body\").addClass('page-contacts'); // $(\"body\").addClass('page-contacts_anim-hidden');\n\n          $(\"body\").removeClass('page-home');\n          $(\"body\").removeClass('first-load');\n          ScrollTrigger.refresh();\n          setTimeout(function () {\n            $(\"body\").addClass('page-contacts_anim-hidden');\n          }, 2000);\n        }); // setTimeout(() => {\n        // \t$(\"body\").addClass('page-contacts_anim-hidden');\n        // }, 2000);\n      }); // end multi page emuljator\n      //accordion\n\n      $(\".acc-bl__cap\").click(function () {\n        if ($(this).parent().hasClass(\"active\")) {\n          $(this).parent().removeClass(\"active\").find(\".acc-bl__body\").slideUp();\n          setTimeout(function () {\n            // scroller.update();\n            //REFRESH\n            // ScrollTrigger.addEventListener('refresh', () => scroller.update())\n            ScrollTrigger.refresh();\n          }, 500);\n        } else {\n          $(\".acc-bl\").removeClass(\"active\").find(\".acc-bl__body\").slideUp();\n          $(this).parent().addClass(\"active\").find(\".acc-bl__body\").slideDown();\n          setTimeout(function () {\n            // scroller.update();\n            //REFRESH\n            // ScrollTrigger.addEventListener('refresh', () => scroller.update())\n            ScrollTrigger.refresh();\n          }, 500);\n        }\n      });\n\n      function validateMob() {\n        var validateForm = document.querySelectorAll('[data-validate]');\n        validateForm.forEach(function (element) {\n          $(\"[data-validate]\").validate({\n            messages: {\n              email: {\n                required: 'Oooops, that email address looks a bit weird',\n                equalTo: 'sadasdas'\n              }\n            },\n            submitHandler: function submitHandler(form) {\n              // form.submit();\n              $(\".contact-section-wrapp\").addClass('send-form'); // $(form).submit();\n            }\n          });\n          $('.contact-end__tt a').hover(function () {\n            $('.contact-end__tt').addClass('hover');\n          }, function () {\n            $('.contact-end__tt').removeClass('hover');\n          });\n        });\n      }\n      /**\n      * demo.js\n      * http://www.codrops.com\n      *\n      * Licensed under the MIT license.\n      * http://www.opensource.org/licenses/mit-license.php\n      * \n      * Copyright 2018, Codrops\n      * http://www.codrops.com\n      */\n\n\n      {\n        // var bodyRect = document.body.getBoundingClientRect(),\n        // elemRect = element.getBoundingClientRect(),\n        // offset   = elemRect.top - bodyRect.top;\n        var getOffset = function getOffset(el) {\n          el = el.getBoundingClientRect();\n          return {\n            left: el.left + window.scrollX,\n            top: el.top + window.scrollY\n          };\n        }; // const txtBL = document.querySelectorAll('.txt-hover-box');\n        // txtBL.forEach(elm => {\n        // \t\telm.addEventListener('mousemove', function(e) {\n        // \t\t\t\t// getOffset(elm)\n        // \t\t\t\t// console.log(getOffset(elm));\n        // \t\t\t\t// var rect = elm.getBoundingClientRect();\n        // \t\t\t\t// console.log( rect.x, rect.y, rect.width, rect.height);\n        // \t\t\t\t// let x = e.pageX,\n        // \t\t\t\t// \t\ty = e.pageY;\n        // \t\t\t\t// console.log(`${x - elm.offsetLeft}:${y+scroller.scroll.instance.scroll.y-elm.offsetTop}`);\n        // \t\t\t\t// console.log(e.pageY);\n        // \t\t\t\t// console.log(elm.offsetTop);\n        // \t\t\t\tconsole.log(scroller.scroll.instance.scroll.y);\n        // \t\t})\n        // });\n        // alert('Element is ' + offset + ' vertical pixels from <body>');\n        // console.log('Element is ' + offset + ' vertical pixels from <body>');\n\n\n        var mapNumber = function mapNumber(X, A, B, C, D) {\n          return (X - A) * (D - C) / (B - A) + C;\n        }; // from http://www.quirksmode.org/js/events_properties.html#position\n\n\n        var getMousePos = function getMousePos(e) {\n          var posx = 0;\n          var posy = 0;\n          if (!e) e = window.event;\n\n          if (e.pageX || e.pageY) {\n            posx = e.pageX;\n            posy = e.pageY;\n          } else if (e.clientX || e.clientY) {\n            posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n          }\n\n          return {\n            x: posx,\n            y: posy\n          };\n        }; // Generate a random float.\n\n\n        var getRandomFloat = function getRandomFloat(min, max) {\n          return (Math.random() * (max - min) + min).toFixed(2);\n        };\n        /**\n         * One class per effect. \n         * Lots of code is repeated, so that single effects can be easily used. \n         */\n        // Effect 3\n\n\n        var HoverImgFx3 = /*#__PURE__*/function () {\n          function HoverImgFx3(el) {\n            _classCallCheck(this, HoverImgFx3);\n\n            this.DOM = {\n              el: el\n            };\n            this.DOM.reveal = document.createElement('div');\n            this.DOM.reveal.className = 'hover-reveal';\n            this.DOM.reveal.style.overflow = 'hidden';\n            this.DOM.reveal.innerHTML = \"<div class=\\\"hover-reveal__inner\\\"><div class=\\\"hover-reveal__img\\\" style=\\\"background-image:url(\".concat(this.DOM.el.dataset.img, \")\\\"></div></div>\");\n            this.DOM.el.appendChild(this.DOM.reveal);\n            this.DOM.revealInner = this.DOM.reveal.querySelector('.hover-reveal__inner');\n            this.DOM.revealInner.style.overflow = 'hidden';\n            this.DOM.revealImg = this.DOM.revealInner.querySelector('.hover-reveal__img'); //   charming(this.DOM.el);\n            //   this.DOM.letters = [...this.DOM.el.querySelectorAll('span')];\n\n            this.initEvents();\n          }\n\n          _createClass(HoverImgFx3, [{\n            key: \"initEvents\",\n            value: function initEvents() {\n              var _this4 = this;\n\n              this.positionElement = function (ev) {\n                var mousePos = getMousePos(ev);\n                var docScrolls = {\n                  left: document.body.scrollLeft + document.documentElement.scrollLeft,\n                  top: document.body.scrollTop + document.documentElement.scrollTop\n                };\n                _this4.DOM.reveal.style.top = \"\".concat(mousePos.y + 20 - docScrolls.top, \"px\");\n                _this4.DOM.reveal.style.left = \"\".concat(mousePos.x + 20 - docScrolls.left, \"px\");\n              };\n\n              this.mouseenterFn = function (ev) {\n                _this4.positionElement(ev);\n\n                _this4.showImage(); //   this.animateLetters();\n\n              };\n\n              this.mousemoveFn = function (ev) {\n                return requestAnimationFrame(function () {\n                  _this4.positionElement(ev);\n                });\n              };\n\n              this.mouseleaveFn = function () {\n                _this4.hideImage();\n              };\n\n              this.DOM.el.addEventListener('mouseenter', this.mouseenterFn);\n              this.DOM.el.addEventListener('mousemove', this.mousemoveFn);\n              this.DOM.el.addEventListener('mouseleave', this.mouseleaveFn);\n            }\n          }, {\n            key: \"showImage\",\n            value: function showImage() {\n              var _this5 = this;\n\n              TweenMax.killTweensOf(this.DOM.revealInner);\n              TweenMax.killTweensOf(this.DOM.revealImg);\n              this.tl = new TimelineMax({\n                onStart: function onStart() {\n                  _this5.DOM.reveal.style.opacity = 1;\n                  TweenMax.set(_this5.DOM.el, {\n                    zIndex: 1000\n                  });\n                }\n              }).add('begin').set([this.DOM.revealInner, this.DOM.revealImg], {\n                transformOrigin: '50% 100%'\n              }).add(new TweenMax(this.DOM.revealInner, 0.4, {\n                ease: Expo.easeOut,\n                startAt: {\n                  x: '50%',\n                  y: '120%',\n                  rotation: 50\n                },\n                x: '0%',\n                y: '0%',\n                rotation: 0\n              }), 'begin').add(new TweenMax(this.DOM.revealImg, 0.4, {\n                ease: Expo.easeOut,\n                startAt: {\n                  x: '-50%',\n                  y: '-120%',\n                  rotation: -50\n                },\n                x: '0%',\n                y: '0%',\n                rotation: 0\n              }), 'begin').add(new TweenMax(this.DOM.revealImg, 0.7, {\n                ease: Expo.easeOut,\n                startAt: {\n                  scale: 2\n                },\n                scale: 1\n              }), 'begin');\n            }\n          }, {\n            key: \"hideImage\",\n            value: function hideImage() {\n              var _this6 = this;\n\n              TweenMax.killTweensOf(this.DOM.revealInner);\n              TweenMax.killTweensOf(this.DOM.revealImg);\n              this.tl = new TimelineMax({\n                onStart: function onStart() {\n                  TweenMax.set(_this6.DOM.el, {\n                    zIndex: 999\n                  });\n                },\n                onComplete: function onComplete() {\n                  TweenMax.set(_this6.DOM.el, {\n                    zIndex: ''\n                  });\n                  TweenMax.set(_this6.DOM.reveal, {\n                    opacity: 0\n                  });\n                }\n              }).add('begin').add(new TweenMax(this.DOM.revealInner, 0.6, {\n                ease: Expo.easeOut,\n                y: '-120%',\n                rotation: -5\n              }), 'begin').add(new TweenMax(this.DOM.revealImg, 0.6, {\n                ease: Expo.easeOut,\n                y: '120%',\n                rotation: 5,\n                scale: 1.2\n              }), 'begin');\n            }\n          }, {\n            key: \"animateLetters\",\n            value: function animateLetters() {\n              TweenMax.killTweensOf(this.DOM.letters);\n              TweenMax.set(this.DOM.letters, {\n                opacity: 0\n              });\n              TweenMax.staggerTo(this.DOM.letters, 0.2, {\n                ease: Expo.easeOut,\n                startAt: {\n                  x: '100%'\n                },\n                x: '0%',\n                opacity: 1\n              }, 0.03);\n            }\n          }]);\n\n          return HoverImgFx3;\n        }();\n\n        _toConsumableArray(document.querySelectorAll('[data-fx=\"3\"] > .txt-hover-img, .txt-hover-img[data-fx=\"3\"]')).forEach(function (link) {\n          return new HoverImgFx3(link);\n        }); // Demo purspose only: Preload all the images in the page..\n        //   const contentel = document.querySelector('.content');\n        //   [...document.querySelectorAll('.block__title, .block__link, .content__text-link')].forEach((el) => {\n        //       const imgsArr = el.dataset.img.split(',');\n        //       for (let i = 0, len = imgsArr.length; i <= len-1; ++i ) {\n        //           const imgel = document.createElement('img');\n        //           imgel.style.visibility = 'hidden';\n        //           imgel.style.width = 0;\n        //           imgel.src = imgsArr[i];\n        //           imgel.className = 'preload';\n        //           contentel.appendChild(imgel);\n        //       }\n        //   });\n        //   imagesLoaded(document.querySelectorAll('.preload'), () => document.body.classList.remove('loading'));\n\n      }\n      ScrollTrigger.defaults({\n        scroller: document.body\n      }); // Listen for orientation changes\n\n      window.addEventListener(\"resize\", function () {\n        ScrollTrigger.refresh();\n      }, false);\n    }\n  }); // setTimeout(() => {  \n  //   scroller.destroy();\n  // }, 0);\n  // setTimeout(() => {  \n  // \t\tscroller.init();\n  // }, 50);\n  // setTimeout(() => {  \n  // \t\tscroller.update();\n  // }, 1000);\n  // const wrapper = document.querySelector(wrapper)\n  // const showAnim = gsap.from('.header', { \n  // \tyPercent: -100,\n  // \tpaused: true,\n  // \tduration: 0.2\n  // }).progress(1);\n  // ScrollTrigger.create({\n  // \ttrigger: wrapper,\n  // \tstart: \"top top\",\n  // \tscroller: wrapper,\n  // \tmarkers: true,\n  // \tend: 99999,\n  // \ttoggleClass: 'active',\n  // \tonUpdate: (wrapper) => {\n  // \t\twrapper.direction === -1 ? showAnim.play() : showAnim.reverse();\n  // \t\tconsole.log(\"object\");\n  // \t}\n  // });\n  // const header = document.querySelector('.header')\n  // \tconst header = document.getElementById('header');\n  // \tlet hiddenMy = false,\n  // \t\t\tstaticMy = true;\n  // // const scroll = new LocomotiveScroll(options);\n  // scroller.on('scroll', ()=>{\n  // \tlet headerHeight = header.getBoundingClientRect().height;\n  // \tif(instance.direction === 'down' && staticMy){\n  // \t\tif(instance.scroll.y > headerHeight){\n  // \t\t\theader.classList.add('pinned');\t  \n  // \t\t\tif(header.classList.contains('home')){\n  // \t\t\t\theader.classList.remove('navbar-light','bg-light');\n  // \t\t\t\theader.classList.add('navbar-dark','bg-dark');\n  // \t\t\t}\n  // \t\t\tstaticMy = false;\n  // \t\t}\n  // \t}\n  // \tif(instance.direction === 'up' && !staticMy){\n  // \t\tif(instance.scroll.y <= headerHeight){\n  // \t\t\theader.classList.remove('pinned');\n  // \t\t\tif(header.classList.contains('home')){\n  // \t\t\t\theader.classList.remove('navbar-dark','bg-dark');\n  // \t\t\t\theader.classList.add('navbar-light','bg-light');\n  // \t\t\t}\n  // \t\t\tstaticMy = true;\n  // \t\t}\n  // \t}\n  // \tif(instance.direction === 'down' && !hiddenMy){\n  // \t\tif(instance.scroll.y>(headerHeight+200)){\n  // \t\t\t//console.log('hiddenMy');\n  // \t\t\theader.classList.remove('pinned');\n  // \t\t\theader.classList.add('unpinned');\n  // \t\t\thiddenMy = true;\n  // \t\t}\n  // \t}\n  // \tif(instance.direction === 'up' && hiddenMy){\n  // \t\t//console.log('show');\n  // \t\theader.classList.remove('unpinned');\n  // \t\theader.classList.add('pinned');\n  // \t\thiddenMy = false;\n  // \t}\n  // });\n  // document.querySelector('.hero-home__tt').addEventListener('mousemove', function (e) {\n  // \t// console.log(document.querySelector('.hero-home__tt').scrollTo(target, options));\n  // \t// console.log(scroller.scroll.instance.scroll.y);\n  // })\n  // locoScroll.on(\"scroll\", ScrollTrigger.update);\n  // tell ScrollTrigger to use these proxy methods for the \".smooth-scroll\" element since Locomotive Scroll is hijacking things\n  // ScrollTrigger.scrollerProxy(\".smooth-scroll\", {\n  // \tscrollTop(value) {\n  // \t\treturn arguments.length ? locoScroll.scrollTo(value, 0, 0) : locoScroll.scroll.instance.scroll.y;\n  // \t}, // we don't have to define a scrollLeft because we're only scrolling vertically.\n  // \tgetBoundingClientRect() {\n  // \t\treturn {top: 0, left: 0, width: window.innerWidth, height: window.innerHeight};\n  // \t},\n  // \t// LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\n  // \tpinType: document.querySelector(\".smooth-scroll\").style.transform ? \"transform\" : \"fixed\"\n  // });\n  // header fix\n  // const wrapper = document.querySelector(wrapper);\n\n  headerFix();\n\n  function headerFix() {\n    var header = document.querySelector('.header');\n    ScrollTrigger.create({\n      trigger: wrapper,\n      start: function start() {\n        return \"+=\" + 10 + \" top\";\n      },\n      // scroller: wrapper,\n      // markers: true,\n      // onUpdate: (self) => {\n      // \tself.direction === -1 ? showAnim.play() : showAnim.reverse();\n      // \tself.direction === -1 ? headerActive() : headerActiveRev();\n      // },\n      onEnter: function onEnter() {\n        header.classList.add('visible'); // header.classList.add('hidden')\n      },\n      onLeaveBack: function onLeaveBack() {\n        header.classList.remove('visible'); // header.classList.remove('hidden')\n      }\n    });\n  } // end header fix\n  //SPLITING TEXT\n\n\n  function splitting(el1, value) {\n    el1.classList.add('splitting');\n    var lines = new split_type__WEBPACK_IMPORTED_MODULE_0__[\"default\"](el1, {\n      tagName: 'div'\n    });\n    lines.split('lines');\n    var line = el1.querySelectorAll('.word');\n    gsap.fromTo(line, {\n      yPercent: 100\n    }, {\n      yPercent: 0,\n      duration: 1,\n      delay: value,\n      ease: \"power4\",\n      stagger: 0.05\n    });\n  }\n\n  var designEl = document.querySelectorAll('.split-hero');\n  designEl.forEach(function (el) {\n    if (document.body.classList.contains('first-load')) {\n      splitting(el, 4);\n    } else {\n      splitting(el, 0);\n    }\n  });\n  var designElSecond = document.querySelectorAll('.split-hero-second');\n  designElSecond.forEach(function (el) {\n    if (document.body.classList.contains('first-load')) {\n      splitting(el, 4.8);\n    } else {\n      splitting(el, 1);\n    }\n  }); // SPLITING TEXT END\n  //anim logo\n\n  animLogotypes();\n\n  function animLogotypes() {\n    var animLogo = document.querySelectorAll('[data-anim-logos]');\n    animLogo.forEach(function (i) {\n      gsap.timeline({\n        scrollTrigger: {\n          trigger: i,\n          // scroller: wrapper,\n          toggleActions: \"play none none none\",\n          start: \"top bottom-=100px\",\n          end: \"top top\",\n          toggleClass: \"active\"\n        }\n      });\n    });\n  } // end anim logo\n  //anim card\n\n\n  animCard();\n\n  function animCard() {\n    var animFadeY = document.querySelectorAll(\"[data-anim-fadey]\");\n    var animDuration = 0.9;\n    var animToggleActions = \"play none none none\";\n    var animStart = \"top bottom-=100px\";\n    var animEnd = \"top top\";\n    animFadeY.forEach(function (animFY) {\n      gsap.timeline({\n        scrollTrigger: {\n          trigger: animFY,\n          // scroller: wrapper,\n          toggleActions: animToggleActions,\n          start: animStart,\n          end: animEnd\n        }\n      }).fromTo(animFY, {\n        y: 64,\n        opacity: 0\n      }, {\n        y: 0,\n        opacity: 1,\n        duration: animDuration,\n        delay: animFY.dataset.animFadey,\n        ease: \"Power3.easeInOut\"\n      });\n    });\n  } // end anim card\n  // ScrollTrigger.create({\n  // \t\ttrigger: '.image-mask',\n  // \t\tscroller: '.container',\n  // \t\tstart: 'top+=30% 50%',\n  // \t\tend: 'bottom-=40% 50%',\n  // \t\tanimation: gsap.to('.image-mask', {backgroundSize: '120%'}),\n  // \t\tscrub: 2,\n  // \t\t// markers: true\n  // })\n  // let container = document.querySelector('.team-list')\n  // const scrollBar = gsap.to('.scrollbar', { x: () => { return window.innerWidth - (150 + 20) }, ease: \"none\" })\n  // ScrollTrigger.create({\n  // \t\ttrigger: \".team-list\",\n  // \t\tscroller: wrapper,\n  // \t\tstart: \"top top\",\n  // \t\tend: () => (container.scrollWidth - window.innerWidth),\n  // \t\tpin: true,\n  // \t\tanticipatePin: 1,\n  // \t\tscrub: scrubValue,\n  // \t\t// animation: scrollBar,\n  // \t\tinvalidateOnRefresh: true,\n  // })\n  // TEAM SLIDER\n\n\n  teamSlider();\n\n  function teamSlider() {\n    var $intro = document.querySelectorAll(\"[data-team-scroll-horyzontall]\");\n    $intro.forEach(function (intro) {\n      var container = intro.querySelector(\".team-slider\");\n      var h = document.querySelector('.header');\n      var hH = h.offsetHeight; // console.log(hH);\n      // gsap.to(container, {\n      // \t// duration: 2,\n      // \tx: () => -(container.scrollWidth - container.offsetWidth),\n      // \t// x: -100,\n      // \tease: \"none\",\n      // \tscrollTrigger: {\n      // \t\ttrigger: intro,\n      // \t\tscroller: wrapper,\n      // \t\t// start: () => \"+=\" + ((container.offsetHeight / 2) + (intro.offsetHeight - container.offsetHeight)) + \" center\",\n      // \t\t// start: () => \"+=\" + (intro.offsetHeight / 2) + \" center\",\n      // \t\tstart: () => \"+=\" + (-hH) + \" top\",\n      // \t\t// start: \"top top\",\n      // \t\t// invalidateOnRefresh: true,\n      // \t\t// markers: true,\n      // \t\tscrub: true,\n      // \t\tpin: true,\n      // \t\tend: () => \"+=\" + (container.scrollWidth - container.offsetWidth)\n      // \t}\n      // })\n\n      var tl1 = gsap.timeline().to(container, {\n        x: function x() {\n          return -(container.scrollWidth - container.offsetWidth);\n        },\n        ease: \"none\"\n      });\n      var inner = intro.querySelector('.team-list__inner');\n\n      if (window.matchMedia(\"(max-width: 767px)\").matches) {\n        sliderDesk();\n      } else if (window.matchMedia(\"(max-width: 1053px)\").matches) {\n        sliderTabl();\n      } else {\n        sliderDesk();\n      }\n\n      function sliderTabl() {\n        ScrollTrigger.create({\n          trigger: intro,\n          // start: () => \"+=\" + (-hH) + \" top\",\n          // start: () => \"+=\" + (-inner.offsetHeight / 2) + \" top\",\n          // start: () => (-(inner.offsetHeight / 2)) + \" top\",\n          start: function start() {\n            return \"+=\" + inner.offsetHeight / 2 + \" center\";\n          },\n          invalidateOnRefresh: true,\n          // markers: true,\n          scrub: true,\n          pin: true,\n          end: function end() {\n            return \"+=\" + (container.scrollWidth - container.offsetWidth);\n          },\n          animation: tl1\n        });\n      }\n\n      function sliderDesk() {\n        ScrollTrigger.create({\n          trigger: intro,\n          start: function start() {\n            return \"+=\" + -hH + \" top\";\n          },\n          // start: () => \"+=\" + (-inner.offsetHeight / 2) + \" top\",\n          // start: () => (-(inner.offsetHeight / 2)) + \" top\",\n          // start: () => \"+=\" + (inner.offsetHeight / 2) + \" center\",\n          invalidateOnRefresh: true,\n          // markers: true,\n          scrub: true,\n          pin: true,\n          end: function end() {\n            return \"+=\" + (container.scrollWidth - container.offsetWidth);\n          },\n          animation: tl1\n        });\n      }\n    });\n  } // var tl;\n  // function start() {\n  // \tvar sw = window.innerWidth / 2 - 50;\n  // \ttl = new TimelineMax({repeat: -1});\n  // \t...\n  // }\n  // SERVICE SLIDER IMAGE AND TEXT\n\n\n  function serviceDesk() {\n    var $service = document.querySelectorAll('[data-service-anim]');\n    $service.forEach(function (service) {\n      var card = service.querySelector('.service-card-grid');\n      var container = service.querySelector('[data-desk-box]');\n      var item = service.querySelector('[data-desk-box] .service-card');\n      var h = document.querySelector('.header');\n      var hH = h.offsetHeight;\n      var scrollTween = gsap.to(card, {\n        // xPercent: -100 * (sections.length - 1),\n        // x: () => -(card.scrollWidth - (container.offsetWidth - card.offsetWidth) - item.clientWidth),\n        x: function x() {\n          return -(card.scrollWidth - item.clientWidth);\n        },\n        ease: \"none\"\n      });\n      var inner = service.querySelector('.service-box__inner');\n\n      if (window.matchMedia(\"(max-width: 1053px)\").matches) {\n        scrolltrigerTablet();\n      } else {\n        scrolltrigerDesc();\n      }\n\n      function scrolltrigerTablet() {\n        ScrollTrigger.create({\n          trigger: service,\n          // start: () => \"+=\" + ((container.offsetHeight / 2) + (service.offsetHeight - container.offsetHeight)) + \" center\",\n          // start: () => \"+=\" + ((container.offsetHeight / 2) + (service.offsetHeight - container.offsetHeight)) + \" center\",\n          // start: () => \"+=\" + (-hH) + \" top\",\n          start: function start() {\n            return \"+=\" + inner.offsetHeight / 2 + \" center\";\n          },\n          pin: true,\n          // pinReparent: true,\n          invalidateOnRefresh: true,\n          invalidateOnResize: true,\n          scrub: true,\n          end: function end() {\n            return \"+=\" + (card.scrollWidth - item.clientWidth) * 2;\n          },\n          animation: scrollTween // onUpdate: ScrollTrigger.update\n\n        });\n      }\n\n      function scrolltrigerDesc() {\n        ScrollTrigger.create({\n          trigger: service,\n          // start: () => \"+=\" + ((container.offsetHeight / 2) + (service.offsetHeight - container.offsetHeight)) + \" center\",\n          // start: () => \"+=\" + ((container.offsetHeight / 2) + (service.offsetHeight - container.offsetHeight)) + \" center\",\n          start: function start() {\n            return \"+=\" + -hH + \" top\";\n          },\n          // start: () => \"+=\" + (inner.offsetHeight / 2) + \" center\",\n          pin: true,\n          // pinReparent: true,\n          invalidateOnRefresh: true,\n          invalidateOnResize: true,\n          scrub: true,\n          end: function end() {\n            return \"+=\" + (card.scrollWidth - item.clientWidth) * 2;\n          },\n          animation: scrollTween // onUpdate: ScrollTrigger.update\n\n        });\n      } // ScrollTrigger.create({\n      // \ttrigger: service,\n      // \t// start: () => \"+=\" + ((container.offsetHeight / 2) + (service.offsetHeight - container.offsetHeight)) + \" center\",\n      // \t// start: () => \"+=\" + ((container.offsetHeight / 2) + (service.offsetHeight - container.offsetHeight)) + \" center\",\n      // \t// start: () => \"+=\" + (-hH) + \" top\",\n      // \tstart: () => \"+=\" + (inner.offsetHeight / 2) + \" center\",\n      // \tpin: true,\n      // \t// pinReparent: true,\n      // \tinvalidateOnRefresh: true,\n      // \tinvalidateOnResize: true,\n      // \tscrub: true,\n      // \tend: () => \"+=\" + ((card.scrollWidth - item.clientWidth) * 2),\n      // \tanimation: scrollTween,\n      // \t// onUpdate: ScrollTrigger.update\n      // });\n\n\n      var itemActive = service.querySelectorAll('.service-card');\n      itemActive.forEach(function (element) {\n        var wrapBox = document.querySelector('.service-box-wrapp');\n        var hwrapBox = wrapBox.offsetHeight; //1\n\n        function add(value) {\n          if (element.dataset.cardValue === value) {\n            element.classList.add('active');\n          }\n        }\n\n        function rem(value) {\n          if (element.dataset.cardValue === value) {\n            element.classList.remove('active');\n          }\n        }\n\n        var vlOne = \"one\",\n            vlTwo = \"two\",\n            vlThree = \"three\";\n        ScrollTrigger.create({\n          trigger: wrapBox,\n          // markers: true,\n          start: \"top bottom\",\n          end: hwrapBox / 3 + \" center\",\n          toggleActions: \"play none none reset\",\n          scrub: true,\n          toggleClass: {\n            targets: '.service-card__image[data-card-val=' + vlOne + ']',\n            className: \"active\"\n          },\n          onEnter: function onEnter() {\n            add(vlOne);\n          },\n          onLeave: function onLeave() {\n            rem(vlOne);\n          },\n          onEnterBack: function onEnterBack() {\n            add(vlOne);\n          },\n          onLeaveBack: function onLeaveBack() {\n            rem(vlOne);\n          } // onUpdate: ScrollTrigger.update\n\n        }); //2\n\n        ScrollTrigger.create({\n          trigger: wrapBox,\n          // markers: true,\n          start: function start() {\n            return \"+=\" + hwrapBox / 3 + \" center\";\n          },\n          end: function end() {\n            return hwrapBox / 3 * 2 + \" center\";\n          },\n          toggleActions: \"play none none reset\",\n          scrub: true,\n          // onToggle: () => console.log(\"toggled, isActive:\", service.isActive),\n          toggleClass: {\n            targets: '.service-card__image[data-card-val=' + vlTwo + ']',\n            className: \"active\"\n          },\n          onEnter: function onEnter() {\n            add(vlTwo);\n          },\n          onLeave: function onLeave() {\n            rem(vlTwo);\n          },\n          onEnterBack: function onEnterBack() {\n            add(vlTwo);\n          },\n          onLeaveBack: function onLeaveBack() {\n            rem(vlTwo);\n          } // onUpdate: ScrollTrigger.update\n\n        }); //3\n\n        ScrollTrigger.create({\n          trigger: wrapBox,\n          // markers: true,\n          start: function start() {\n            return \"+=\" + hwrapBox / 3 * 2 + \" center\";\n          },\n          end: function end() {\n            return hwrapBox + \" center\";\n          },\n          toggleActions: \"play none none reset\",\n          scrub: true,\n          toggleClass: {\n            targets: '.service-card__image[data-card-val=' + vlThree + ']',\n            className: \"active\"\n          },\n          onEnter: function onEnter() {\n            add(vlThree);\n          },\n          onLeave: function onLeave() {\n            rem(vlThree);\n          },\n          onEnterBack: function onEnterBack() {\n            add(vlThree);\n          },\n          onLeaveBack: function onLeaveBack() {\n            rem(vlThree);\n          } // onUpdate: ScrollTrigger.update\n\n        }); // var cardData = element.dataset.cardValue;\n        // ScrollTrigger.create({\n        // \ttrigger: element,\n        // \t// markers: true,\n        // \tcontainerAnimation: scrollTween,\n        // \tstart: \"left center\",\n        // \tend: \"right center\",\n        // \ttoggleActions: \"play none none reset\",\n        // \tscrub: true,\n        // \t// onRefresh: true,\n        // // onRefresh: killScrub,\n        // \tinvalidateOnRefresh: true,\n        // \tinvalidateOnResize: true,\n        // \tid: \"1\",\n        // \ttoggleClass: {targets: '.service-card__image[data-card-val='+cardData+']', className: \"active\"},\n        // \tonEnter: () => {\n        // \t\telement.classList.add('active');\n        // \t},\n        // \tonLeave: () => {\n        // \t\telement.classList.remove('active');\n        // \t},\n        // \tonEnterBack: () => {\n        // \t\telement.classList.add('active');\n        // \t},\n        // \tonLeaveBack: () => {\n        // \t\telement.classList.remove('active');\n        // \t},\n        //   // onUpdate: ScrollTrigger.update\n        // });\n      });\n    });\n  }\n\n  function serviceMob() {\n    var $serviceMob = document.querySelectorAll('.service-card');\n    $serviceMob.forEach(function (serviceMob) {\n      gsap.from(serviceMob, {\n        scrollTrigger: {\n          start: 'top center',\n          end: 'bottom center',\n          trigger: serviceMob,\n          // scroller: wrapper,\n          // markers: true,\n          toggleClass: 'active'\n        }\n      });\n    });\n  }\n\n  ScrollTrigger.matchMedia({\n    '(min-width: 768px)': function minWidth768px() {\n      serviceDesk();\n    },\n    '(max-width: 767px)': function maxWidth767px() {\n      serviceMob();\n    }\n  }); // end sevice\n  // manifesto gsap\n\n  manifesto();\n\n  function manifesto() {\n    var $manif = document.querySelectorAll('[data-scroll-manif] .txt-hover-box');\n    $manif.forEach(function (manif) {\n      gsap.from(manif, {\n        scrollTrigger: {\n          start: 'top center',\n          end: 'bottom center',\n          trigger: manif,\n          // scroller: wrapper,\n          // markers: true,\n          toggleClass: 'active'\n        }\n      });\n    });\n  } // COUNTER VALUES\n\n\n  counter();\n\n  function counter() {\n    var counterValue = document.querySelectorAll('.value-box__list-item');\n    counterValue.forEach(function (element) {\n      var item = element.querySelector('.value-box__number span');\n      gsap.from(item, {\n        // duration: 2,\n        textContent: 1,\n        duration: 3,\n        ease: \"Power1.easeIn\",\n        snap: {\n          textContent: 1\n        },\n        stagger: 1,\n        // scrub: 1,\n        scrollTrigger: {\n          trigger: element,\n          // scroller: wrapper,\n          // start: () => \"+=\" + ((container.offsetHeight / 2) + (intro.offsetHeight - container.offsetHeight)) + \" center\",\n          start: \"top bottom\" // invalidateOnRefresh: true,\n          // markers: true,\n          // scrub: 1,\n          // pin: true,\n          // end: () => \"+=\" + (container.scrollWidth - container.offsetWidth)\n\n        }\n      });\n    });\n  } // end COUNTER VALUES\n  // FOOTER \n\n\n  function $footerDesc() {\n    var $footer = document.querySelectorAll(\".footer\");\n    $footer.forEach(function (footer) {\n      var b = footer.querySelector('.footer__inner'); // console.log(footer.offsetHeight);\n\n      gsap.timeline({\n        scrollTrigger: {\n          trigger: footer,\n          start: \"top bottom\",\n          end: footer.offsetHeight + \" bottom\",\n          // markers: true,\n          scrub: true\n        }\n      }).fromTo(b, {\n        yPercent: -80\n      }, {\n        yPercent: 0,\n        ease: \"none\"\n      }); // const h = document.querySelector('.header')\n      // scrollTrigger.create({\n      // \ttrigger: wrapper,\n      // \t// scroller: wrapper,\n      // \tstart: \"bottom top\",\n      // \tend: \"bottom bottom\",\n      // \tmarkers: true,\n      // \t// pin: true,\n      // \t// scrub: true,\n      // \t// end: \"top top\",\n      // })\n\n      var main = document.querySelector('.wrapper main');\n      var mainHeight = footer.offsetHeight;\n      ScrollTrigger.create({\n        trigger: main,\n        start: \"bottom +=150px\",\n        end: function end() {\n          return \"+=\" + mainHeight / 1.5;\n        },\n        toggleClass: {\n          targets: '.header',\n          className: \"diference\"\n        }\n      });\n    });\n  }\n\n  $footerDesc();\n  ScrollTrigger.refresh(); // ScrollTrigger.matchMedia({\n  // \t'(min-width: 768px)': () => {\n  // \t\t$footerDesc();\n  // \t}, \n  // \t// '(max-width: 767px)': () => {\n  // \t// \tserviceMob();\n  // \t// },\n  // });\n  // window.addEventListener(\"load\", function(event) {\n  //   ScrollTrigger.refresh();\n  // });\n});\n\n//# sourceURL=webpack://webpack-workflow/./src/scripts/inner/team.js?");

/***/ }),

/***/ "./src/styles/app.scss":
/*!*****************************!*\
  !*** ./src/styles/app.scss ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://webpack-workflow/./src/styles/app.scss?");

/***/ }),

/***/ "./node_modules/split-type/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/split-type/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SplitType)\n/* harmony export */ });\n/**\n * SplitType\n * https://github.com/lukePeavey/SplitType\n * @version 0.3.2\n * @author Luke Peavey <lwpeavey@gmail.com>\n */\n\n// Polyfill the following DOM methods that are not supported in IE 11.\n\n(() => {\n  function append(...nodes) {\n    const length = nodes.length;\n\n    for (let i = 0; i < length; i++) {\n      const node = nodes[i];\n      if (node.nodeType === 1 || node.nodeType === 11) this.appendChild(node);else this.appendChild(document.createTextNode(String(node)));\n    }\n  }\n\n  function replaceChildren(...nodes) {\n    while (this.lastChild) {\n      this.removeChild(this.lastChild);\n    }\n\n    if (nodes.length) this.append(...nodes);\n  }\n\n  function replaceWith(...nodes) {\n    const parent = this.parentNode;\n    let i = nodes.length;\n    if (!parent) return;\n    if (!i) parent.removeChild(this);\n\n    while (i--) {\n      let node = nodes[i];\n\n      if (typeof node !== 'object') {\n        node = this.ownerDocument.createTextNode(node);\n      } else if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n\n      if (!i) {\n        parent.replaceChild(node, this);\n      } else {\n        parent.insertBefore(this.previousSibling, node);\n      }\n    }\n  }\n\n  if (typeof Element !== 'undefined') {\n    if (!Element.prototype.append) {\n      Element.prototype.append = append;\n      DocumentFragment.prototype.append = append;\n    }\n\n    if (!Element.prototype.replaceChildren) {\n      Element.prototype.replaceChildren = replaceChildren;\n      DocumentFragment.prototype.replaceChildren = replaceChildren;\n    }\n\n    if (!Element.prototype.replaceWith) {\n      Element.prototype.replaceWith = replaceWith;\n      DocumentFragment.prototype.replaceWith = replaceWith;\n    }\n  }\n})();\n\n/**\n * Shallow merges the properties of an object with the target object. Only\n * includes properties that exist on the target object. Non-writable properties\n * on the target object will not be over-written.\n *\n * @param {Object} target\n * @param {Object} object\n */\nfunction extend(target, object) {\n  return Object.getOwnPropertyNames(Object(target)).reduce((extended, key) => {\n    const currentValue = Object.getOwnPropertyDescriptor(Object(target), key);\n    const newValue = Object.getOwnPropertyDescriptor(Object(object), key);\n    return Object.defineProperty(extended, key, newValue || currentValue);\n  }, {});\n}\n\n/**\n * Checks if given value is a string\n *\n * @param {any} value\n * @return {boolean} `true` if `value` is a string, else `false`\n */\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\n/**\n * Parses user supplied settings objects.\n */\n\nfunction parseSettings(settings = {}) {\n  const object = extend(settings); // `split` may be used as an alias for the `types` option\n  // Parse the `types` settings into an array of valid split types.\n  // If `types` is explicitly set to an empty string or array, text will not be\n  // split at all.\n\n  let types;\n\n  if (object.types !== undefined) {\n    types = object.types;\n  } else if (object.split !== undefined) {\n    types = object.split;\n  }\n\n  if (types !== undefined) {\n    object.types = (isString(types) || isArray(types) ? String(types) : '').split(',').map(type => String(type).trim()).filter(type => /((line)|(word)|(char))/i.test(type));\n  } // Support `position: absolute` as an alias for `absolute: true`\n\n\n  if (object.absolute || object.position) {\n    object.absolute = object.absolute || /absolute/.test(settings.position);\n  }\n\n  return object;\n}\n\n/**\n * Takes a list of `types` and returns an object\n *\n * @param {string | string[]} value a comma separated list of split types\n * @return {{lines: boolean, words: boolean, chars: boolean}}\n */\n\nfunction parseTypes(value) {\n  const types = isString(value) || isArray(value) ? String(value) : '';\n  return {\n    none: !types,\n    lines: /line/i.test(types),\n    words: /word/i.test(types),\n    chars: /char/i.test(types)\n  };\n}\n\n/**\n * Returns true if `value` is a non-null object.\n * @param {any} value\n * @return {boolean}\n */\nfunction isObject(value) {\n  return value !== null && typeof value === 'object';\n}\n\n/**\n * Returns true if `input` is one of the following:\n * - `Element`\n * - `Text`\n * - `DocumentFragment`\n */\n\nfunction isNode(input) {\n  return isObject(input) && /^(1|3|11)$/.test(input.nodeType);\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n * Original source: Lodash\n *\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3)\n * // => true\n *\n * _.isLength(Number.MIN_VALUE)\n * // => false\n *\n * _.isLength(Infinity)\n * // => false\n *\n * _.isLength('3')\n * // => false\n */\n\nfunction isLength(value) {\n  return typeof value === 'number' && value > -1 && value % 1 === 0;\n}\n/**\n * Checks if `value` is an array-like object\n * @param {any} value\n * @return {boolean} true if `value` is array-like`, else `false`\n * @example\n * isArrayLike(new Array())\n * // => true\n *\n * isArrayLike(document.querySelectorAll('div'))\n * // => true\n *\n * isArrayLike(document.getElementsByTagName('div'))\n * // => true\n *\n * isArrayLike(() => {})\n * // => false\n *\n * isArrayLike({foo: 'bar'})\n * // => false\n *\n * * isArrayLike(null)\n * // => false\n */\n\n\nfunction isArrayLike(value) {\n  return isObject(value) && isLength(value.length);\n}\n\n/**\n * Coerces `value` to an `Array`.\n *\n * @param {any} value\n * @return {any[]}\n * @example\n * // If `value` is any `Array`, returns original `Array`\n * let arr = [1, 2]\n * toArray(arr)\n * // => arr\n *\n * // If `value` is an `ArrayLike`, its equivalent to `Array.from(value)`\n * let nodeList = document.querySelectorAll('div')\n * toArray(nodeList)\n * // => HTMLElement[] s\n *\n * // If value is falsy, returns empty array\n * toArray(null)\n * // => []\n *\n * // For any other type of value, its equivalent to `Array.of(value)`\n * let element = document.createElement('div')\n * toArray(element)\n * // => [element]\n *\n */\n\nfunction toArray(value) {\n  if (isArray(value)) return value;\n  if (value == null) return [];\n  return isArrayLike(value) ? Array.prototype.slice.call(value) : [value];\n}\n\n/**\n * Processes target elements for the splitType function.\n *\n * @param {any} target Can be one of the following:\n * 1. `string` - A css selector\n * 2. `HTMLElement` - A single element\n * 3. `NodeList` - A nodeList\n * 4. `Element[]` - An array of elements\n * 5. `Array<NodeList|Element[]>` - An nested array of elements\n * @returns {Element[]} A flat array HTML elements\n * @return A flat array of elements or empty array if no elements are found\n */\n\nfunction getTargetElements(target) {\n  let elements = target; // If `target` is a selector string...\n\n  if (isString(target)) {\n    if (/^(#[a-z]\\w+)$/.test(target.trim())) {\n      // If `target` is an ID, use `getElementById`\n      elements = document.getElementById(target.trim().slice(1));\n    } else {\n      // Else use `querySelectorAll`\n      elements = document.querySelectorAll(target);\n    }\n  } // Return a flattened array of elements\n\n\n  return toArray(elements).reduce((result, element) => {\n    return [...result, ...toArray(element).filter(isNode)];\n  }, []);\n}\n\nconst {\n  entries,\n  keys,\n  values\n} = Object;\n\nconst expando = `_splittype`;\nconst cache = {};\nlet uid = 0;\n/**\n * Stores data associated with DOM elements or other objects. This is a\n * simplified version of jQuery's data method.\n *\n * @signature Data(owner)\n * @description Get the data store object for the given owner.\n * @param {Object} owner the object that data will be associated with.\n * @return {Object} the data object for given `owner`. If no data exists\n *     for the given object, creates a new data store and returns it.\n *\n * @signature Data(owner, key)\n * @description Get the value\n * @param {Object} owner\n * @param {string} key\n * @return {any} the value of the provided key. If key does not exist, returns\n *     undefined.\n *\n * @signature Data(owner, key, value)\n * @description Sets the given key/value pair in data store\n * @param {Object} owner\n * @param {string} key\n * @param {any} value\n */\n\nfunction set(owner, key, value) {\n  if (!isObject(owner)) {\n    console.warn('[data.set] owner is not an object');\n    return null;\n  }\n\n  const id = owner[expando] || (owner[expando] = ++uid);\n  const data = cache[id] || (cache[id] = {});\n\n  if (value === undefined) {\n    if (!!key && Object.getPrototypeOf(key) === Object.prototype) {\n      cache[id] = { ...data,\n        ...key\n      };\n    }\n  } else if (key !== undefined) {\n    data[key] = value;\n  }\n\n  return value;\n}\nfunction get(owner, key) {\n  const id = isObject(owner) ? owner[expando] : null;\n  const data = id && cache[id] || {};\n\n  if (key === undefined) {\n    return data;\n  }\n\n  return data[key];\n}\n/**\n * Remove all data associated with the given element\n */\n\nfunction remove(element) {\n  const id = element && element[expando];\n\n  if (id) {\n    delete element[id];\n    delete cache[id];\n  }\n}\n/**\n * Remove all temporary data from the store.\n */\n\nfunction cleanup() {\n  entries(cache).forEach(([id, {\n    isRoot,\n    isSplit\n  }]) => {\n    if (!isRoot || !isSplit) {\n      cache[id] = null;\n      delete cache[id];\n    }\n  });\n}\n\n/**\n * Splits a string into an array of words.\n *\n * @param {string} string\n * @param {string | RegExp} [separator = ' ']\n * @return {string[]} Array of words\n */\nfunction toWords(value, separator = ' ') {\n  const string = value ? String(value) : '';\n  return string.trim().replace(/\\s+/g, ' ').split(separator);\n}\n\n/**\n * Based on lodash#split <https://lodash.com/license>\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &\n * Editors\n */\nconst rsAstralRange = '\\\\ud800-\\\\udfff';\nconst rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nconst rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0';\nconst rsVarRange = '\\\\ufe0e\\\\ufe0f';\n/** Used to compose unicode capture groups. */\n\nconst rsAstral = `[${rsAstralRange}]`;\nconst rsCombo = `[${rsComboMarksRange}${rsComboSymbolsRange}]`;\nconst rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nconst rsModifier = `(?:${rsCombo}|${rsFitz})`;\nconst rsNonAstral = `[^${rsAstralRange}]`;\nconst rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nconst rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nconst rsZWJ = '\\\\u200d';\n/** Used to compose unicode regexes. */\n\nconst reOptMod = `${rsModifier}?`;\nconst rsOptVar = `[${rsVarRange}]?`;\nconst rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nconst rsSeq = rsOptVar + reOptMod + rsOptJoin;\nconst rsSymbol = `(?:${[`${rsNonAstral}${rsCombo}?`, rsCombo, rsRegional, rsSurrPair, rsAstral].join('|')}\n)`;\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\nconst reUnicode = RegExp(`${rsFitz}(?=${rsFitz})|${rsSymbol}${rsSeq}`, 'g');\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\nconst unicodeRange = [rsZWJ, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsVarRange];\nconst reHasUnicode = RegExp(`[${unicodeRange.join('')}]`);\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\nfunction asciiToArray(string) {\n  return string.split('');\n}\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\n\n\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\n\n\nfunction stringToArray(string) {\n  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n}\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values.\n *\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\n\nfunction toString(value) {\n  return value == null ? '' : String(value);\n}\n/**\n * Splits `string` into an array of characters. If `separator` is omitted,\n * it behaves likes split.split('').\n *\n * Unlike native string.split(''), it can split strings that contain unicode\n * characters like emojis and symbols.\n *\n * @param {string} [string=''] The string to split.\n * @param {RegExp|string} [separator=''] The separator pattern to split by.\n * @returns {Array} Returns the string segments.\n * @example\n * toChars('foo');\n * // => ['f', 'o', 'o']\n *\n * toChars('foo bar');\n * // => [\"f\", \"o\", \"o\", \" \", \"b\", \"a\", \"r\"]\n *\n * toChars('f😀o');\n * // => ['f', '😀', 'o']\n *\n * toChars('f-😀-o', /-/);\n * // => ['f', '😀', 'o']\n *\n */\n\n\nfunction toChars(string, separator = '') {\n  string = toString(string);\n\n  if (string && isString(string)) {\n    if (!separator && hasUnicode(string)) {\n      return stringToArray(string);\n    }\n  }\n\n  return string.split(separator);\n}\n\n/**\n * Create an HTML element with the the given attributes\n *\n * attributes can include standard HTML attribute, as well as the following\n * \"special\" properties:\n *   - children: HTMLElement | ArrayLike<HTMLElement>\n *   - textContent: string\n *   - innerHTML: string\n *\n * @param {string} name\n * @param  {Object} [attributes]\n * @returns {HTMLElement}\n */\n\nfunction createElement(name, attributes) {\n  const element = document.createElement(name);\n\n  if (!attributes) {\n    // When called without the second argument, its just return the result\n    // of `document.createElement`\n    return element;\n  }\n\n  Object.keys(attributes).forEach(attribute => {\n    const rawValue = attributes[attribute];\n    const value = isString(rawValue) ? rawValue.trim() : rawValue; // Ignore attribute if the value is `null` or an empty string\n\n    if (value === null || value === '') return;\n\n    if (attribute === 'children') {\n      // Children can be one or more Elements or DOM strings\n      element.append(...toArray(value));\n    } else {\n      // Handle standard HTML attributes\n      element.setAttribute(attribute, value);\n    }\n  });\n  return element;\n}\n\nvar defaults = {\n  splitClass: '',\n  lineClass: 'line',\n  wordClass: 'word',\n  charClass: 'char',\n  types: ['lines', 'words', 'chars'],\n  absolute: false,\n  tagName: 'div'\n};\n\n/**\n * Splits the text content of a single TextNode into words and/or characters.\n *\n * This functions gets called for every text node inside the target element. It\n * replaces the text node with a document fragment containing the split text.\n * Returns an array of the split word and character elements from this node.\n *\n * @param {TextNode} textNode\n * @param {Object} settings\n * @return {{words: Element[], chars: Element[]}}\n */\n\nfunction splitWordsAndChars(textNode, settings) {\n  settings = extend(defaults, settings); // The split types\n\n  const types = parseTypes(settings.types); // the tag name for split text nodes\n\n  const TAG_NAME = settings.tagName; // value of the text node\n\n  const VALUE = textNode.nodeValue; // `splitText` is a wrapper to hold the HTML structure\n\n  const splitText = document.createDocumentFragment(); // Arrays of split word and character elements\n\n  let words = [];\n  let chars = [];\n\n  if (/^\\s/.test(VALUE)) {\n    splitText.append(' ');\n  } // Create an array of wrapped word elements.\n\n\n  words = toWords(VALUE).reduce((result, WORD, idx, arr) => {\n    // Let `wordElement` be the wrapped element for the current word\n    let wordElement;\n    let characterElementsForCurrentWord; // -> If splitting text into characters...\n\n    if (types.chars) {\n      // Iterate through the characters in the current word\n      characterElementsForCurrentWord = toChars(WORD).map(CHAR => {\n        const characterElement = createElement(TAG_NAME, {\n          class: `${settings.splitClass} ${settings.charClass}`,\n          style: 'display: inline-block;',\n          children: CHAR\n        });\n        set(characterElement, 'isChar', true);\n        chars = [...chars, characterElement];\n        return characterElement;\n      });\n    } // END IF;\n\n\n    if (types.words || types.lines) {\n      // -> If Splitting Text Into Words...\n      //    Create an element to wrap the current word. If we are also\n      //    splitting text into characters, the word element will contain the\n      //    wrapped character nodes for this word. If not, it will contain the\n      //    plain text content (WORD)\n      wordElement = createElement(TAG_NAME, {\n        class: `${settings.wordClass} ${settings.splitClass}`,\n        style: `display: inline-block; ${types.words && settings.absolute ? `position: relative;` : ''}`,\n        children: types.chars ? characterElementsForCurrentWord : WORD\n      });\n      set(wordElement, {\n        isWord: true,\n        isWordStart: true,\n        isWordEnd: true\n      });\n      splitText.appendChild(wordElement);\n    } else {\n      // -> If NOT splitting into words OR lines...\n      //    Append the characters elements directly to splitText.\n      characterElementsForCurrentWord.forEach(characterElement => {\n        splitText.appendChild(characterElement);\n      });\n    }\n\n    if (idx < arr.length - 1) {\n      // Add a space after the word.\n      splitText.append(' ');\n    } // If not splitting text into words, we return an empty array\n\n\n    return types.words ? result.concat(wordElement) : result;\n  }, []); // END LOOP;\n  // Add a trailing white space to maintain word spacing\n\n  if (/\\s$/.test(VALUE)) {\n    splitText.append(' ');\n  }\n\n  textNode.replaceWith(splitText);\n  return {\n    words,\n    chars\n  };\n}\n\n/**\n * Splits the text content of a target element into words and/or characters.\n * The function is recursive, it will also split the text content of any child\n * elements into words/characters, while preserving the nested elements.\n *\n * @param {Node} node an HTML Element or Text Node\n * @param {Object} setting splitType settings\n */\n\nfunction split(node, settings) {\n  const type = node.nodeType; // Arrays of split words and characters\n\n  const wordsAndChars = {\n    words: [],\n    chars: []\n  }; // Only proceed if `node` is an `Element`, `Fragment`, or `Text`\n\n  if (!/(1|3|11)/.test(type)) {\n    return wordsAndChars;\n  } // A) IF `node` is TextNode that contains characters other than white space...\n  //    Split the text content of the node into words and/or characters\n  //    return an object containing the split word and character elements\n\n\n  if (type === 3 && /\\S/.test(node.nodeValue)) {\n    return splitWordsAndChars(node, settings);\n  } // B) ELSE `node` is an 'Element'\n  //    Iterate through its child nodes, calling the `split` function\n  //    recursively for each child node.\n\n\n  const childNodes = toArray(node.childNodes);\n\n  if (childNodes.length) {\n    set(node, 'isSplit', true); // we need to set a few styles on nested html elements\n\n    if (!get(node).isRoot) {\n      node.style.display = 'inline-block';\n      node.style.position = 'relative'; // To maintain original spacing around nested elements when we are\n      // splitting text into lines, we need to check if the element should\n      // have a space before and after, and store that value for later.\n      // Note: this was necessary to maintain the correct spacing when nested\n      // elements do not align with word boundaries. For example, a nested\n      // element only wraps part of a word.\n\n      const nextSibling = node.nextSibling;\n      const prevSibling = node.previousSibling;\n      const text = node.textContent || '';\n      const textAfter = nextSibling ? nextSibling.textContent : ' ';\n      const textBefore = prevSibling ? prevSibling.textContent : ' ';\n      set(node, {\n        isWordEnd: /\\s$/.test(text) || /^\\s/.test(textAfter),\n        isWordStart: /^\\s/.test(text) || /\\s$/.test(textBefore)\n      });\n    }\n  } // Iterate through child nodes, calling `split` recursively\n  // Returns an object containing all split words and chars\n\n\n  return childNodes.reduce((result, child) => {\n    const {\n      words,\n      chars\n    } = split(child, settings);\n    return {\n      words: [...result.words, ...words],\n      chars: [...result.chars, ...chars]\n    };\n  }, wordsAndChars);\n}\n\n/**\n * Gets the height and position of an element relative to offset parent.\n * Should be equivalent to offsetTop and offsetHeight, but with sub-pixel\n * precision.\n *\n * TODO needs work\n */\nfunction getPosition(node, isWord, settings, scrollPos) {\n  if (!settings.absolute) {\n    return {\n      top: isWord ? node.offsetTop : null\n    };\n  }\n\n  const parent = node.offsetParent;\n  const [scrollX, scrollY] = scrollPos;\n  let parentX = 0;\n  let parentY = 0;\n\n  if (parent && parent !== document.body) {\n    const parentRect = parent.getBoundingClientRect();\n    parentX = parentRect.x + scrollX;\n    parentY = parentRect.y + scrollY;\n  }\n\n  const {\n    width,\n    height,\n    x,\n    y\n  } = node.getBoundingClientRect();\n  const top = y + scrollY - parentY;\n  const left = x + scrollX - parentX;\n  return {\n    width,\n    height,\n    top,\n    left\n  };\n}\n\n/**\n * Recursively \"un-splits\" text into words.\n * This is used when splitting text into lines but not words.\n * We initially split the text into words so we can maintain the correct line\n * breaks. Once text has been split into lines, we \"un-split\" the words...\n * @param {Element}\n * @return {void}\n */\n\nfunction unSplitWords(element) {\n  if (!get(element).isWord) {\n    toArray(element.children).forEach(child => unSplitWords(child));\n  } else {\n    remove(element);\n    element.replaceWith(...element.childNodes);\n  }\n}\n\nconst createFragment = () => document.createDocumentFragment();\n\nfunction repositionAfterSplit(element, settings, scrollPos) {\n  const types = parseTypes(settings.types);\n  const TAG_NAME = settings.tagName;\n  const nodes = element.getElementsByTagName('*');\n  const wordsInEachLine = [];\n  let wordsInCurrentLine = [];\n  let lineOffsetY = null;\n  let elementHeight;\n  let elementWidth;\n  let contentBox;\n  let lines = [];\n  /**------------------------------------------------\n   ** GET STYLES AND POSITIONS\n   **-----------------------------------------------*/\n  // There is no built-in way to detect natural line breaks in text (when a\n  // block of text wraps to fit its container). To split text into lines, we\n  // have to detect line breaks by checking the top offset of words. This is\n  // why text was split into words first. To apply absolute\n  // positioning, its also necessary to record the size and position of every\n  // split node (lines, words, characters).\n  // To consolidate DOM getting/settings, this is all done at the same time,\n  // before actually splitting text into lines, which involves restructuring\n  // the DOM again.\n  // Cache the element's parent and next sibling (for DOM removal).\n\n  const parent = element.parentElement;\n  const nextSibling = element.nextElementSibling; // a wrapper for the new HTML structure\n\n  const splitText = createFragment(); // get the computed style object for the element\n\n  const cs = window.getComputedStyle(element);\n  const align = cs.textAlign;\n  const fontSize = parseFloat(cs.fontSize);\n  const lineThreshold = fontSize * 0.2; // IF using absolute position...\n\n  if (settings.absolute) {\n    // Let contentBox be an object containing the width and offset position of\n    // the element's content box (the area inside padding box). This is needed\n    // (for absolute positioning) to set the width and position of line\n    // elements, which have not been created yet.\n    contentBox = {\n      left: element.offsetLeft,\n      top: element.offsetTop,\n      width: element.offsetWidth\n    }; // Let elementWidth and elementHeight be the actual width/height of the\n    // element. Also check if the element has inline height or width styles\n    // already set. If it does, cache those values for later.\n\n    elementWidth = element.offsetWidth;\n    elementHeight = element.offsetHeight; // Store the original inline height and width of the element\n\n    set(element, {\n      cssWidth: element.style.width,\n      cssHeight: element.style.height\n    });\n  } // Iterate over every node in the target element\n\n\n  toArray(nodes).forEach(node => {\n    // node is a word element or custom html element\n    const isWordLike = node.parentElement === element; // TODO needs work\n    // Get te size and position of split text nodes\n\n    const {\n      width,\n      height,\n      top,\n      left\n    } = getPosition(node, isWordLike, settings, scrollPos); // If element is a `<br>` tag return here\n\n    if (/^br$/i.test(node.nodeName)) return;\n\n    if (types.lines && isWordLike) {\n      // We compare the top offset of the current word to the top offset of\n      // previous words on the current line. If the difference is greater than\n      // our defined threshold (20%), we assume this word is on a new line.\n      if (lineOffsetY === null || top - lineOffsetY >= lineThreshold) {\n        lineOffsetY = top;\n        wordsInEachLine.push(wordsInCurrentLine = []);\n      } // Add the current word node to the line array\n\n\n      wordsInCurrentLine.push(node);\n    } // END IF\n\n\n    if (settings.absolute) {\n      // Store the size and position split text nodes\n      set(node, {\n        top,\n        left,\n        width,\n        height\n      });\n    }\n  }); // END LOOP\n  // Remove the element from the DOM\n\n  if (parent) {\n    parent.removeChild(element);\n  }\n  /**------------------------------------------------\n   ** SPLIT LINES\n   **-----------------------------------------------*/\n\n\n  if (types.lines) {\n    // Iterate over lines of text (see 11 b)\n    // Let `line` be the array of words in the current line.\n    // Return an array of the wrapped line elements (lineElements)\n    lines = wordsInEachLine.map(wordsInThisLine => {\n      // Create an element to wrap the current line.\n      const lineElement = createElement(TAG_NAME, {\n        class: `${settings.splitClass} ${settings.lineClass}`,\n        style: `display: block; text-align: ${align}; width: 100%;`\n      });\n      set(lineElement, 'isLine', true);\n      const lineDimensions = {\n        height: 0,\n        top: 1e4\n      }; // Append the `lineElement` to `container`\n\n      splitText.appendChild(lineElement); // Iterate over the word-level elements in the current line.\n      // Note: wordOrElement can either be a word node or nested element\n\n      wordsInThisLine.forEach((wordOrElement, idx, arr) => {\n        const {\n          isWordEnd,\n          top,\n          height\n        } = get(wordOrElement);\n        const next = arr[idx + 1]; // Determine line height / y-position\n        // we use the height and offsetTop of the words which we already\n        // recorded. Because custom nested elements could have their own\n        // styles, the words on a line may not all be the same height or\n        // y position. So we take the greatest height / y - offset of the\n        // words on this line.\n\n        lineDimensions.height = Math.max(lineDimensions.height, height);\n        lineDimensions.top = Math.min(lineDimensions.top, top); // append the current word/element\n\n        lineElement.appendChild(wordOrElement); // Determine if there should space after the current element...\n        // If this is not the last word on the current line.\n        // TODO - logic for handing spacing can be improved\n\n        if (isWordEnd && get(next).isWordStart) {\n          lineElement.append(' ');\n        }\n      }); // END LOOP\n\n      if (settings.absolute) {\n        set(lineElement, {\n          height: lineDimensions.height,\n          top: lineDimensions.top\n        });\n      }\n\n      return lineElement;\n    }); // END LOOP\n\n    if (!types.words) {\n      unSplitWords(splitText);\n    } // 10. Insert the new container\n\n\n    element.replaceChildren(splitText);\n  }\n  /**------------------------------------------------\n   **  SET ABSOLUTE POSITION\n   **-----------------------------------------------*/\n  // Apply absolute positioning to all child elements of the target element.\n  // This includes split lines, words, chars, and custom HTML elements that were\n  // included by the user. The size and position of child elements has already\n  // been recorded before splitting text into lines.\n\n\n  if (settings.absolute) {\n    // Set the width/height of the parent element so it does not collapse\n    // when its children are set to absolute position.\n    element.style.width = `${element.style.width || elementWidth}px`;\n    element.style.height = `${elementHeight}px`; // Iterate over all child elements\n\n    toArray(nodes).forEach(node => {\n      const {\n        isLine,\n        top,\n        left,\n        width,\n        height\n      } = get(node);\n      const parentData = get(node.parentElement);\n      const isChildOfLineNode = !isLine && parentData.isLine; // Set the top position of the current node.\n      // -> If `node` a line element, we use the top offset of its first child\n      // -> If `node` the child of line element, then its top offset is zero\n\n      node.style.top = `${isChildOfLineNode ? top - parentData.top : top}px`; // Set the left position of the current node.\n      // -> IF `node` is a line element, this is equal to the position left of\n      //    the content box of the parent element\n      // -> IF `node` is the child of a line element, the value has to adjusted\n      //    so its relative to the line element\n\n      node.style.left = isLine ? `${contentBox.left}px` : `${left - (isChildOfLineNode ? contentBox.left : 0)}px`; // Set the height of the current node to the cached value.\n\n      node.style.height = `${height}px`; //  Set the width of the current node.\n      //  If its a line element, width is equal to the width of the contentBox.\n\n      node.style.width = isLine ? `${contentBox.width}px` : `${width}px`; // Finally, set the node's position to absolute.\n\n      node.style.position = 'absolute';\n    });\n  } // end if;\n  // 14. Re-attach the element to the DOM\n\n\n  if (parent) {\n    if (nextSibling) parent.insertBefore(element, nextSibling);else parent.appendChild(element);\n  }\n\n  return lines;\n}\n\nlet _defaults = extend(defaults, {});\n\nclass SplitType {\n  /**\n   * The internal data store\n   */\n  static get data() {\n    return cache;\n  }\n  /**\n   * The default settings for all splitType instances\n   * @static\n   */\n\n\n  static get defaults() {\n    return _defaults;\n  }\n  /**\n   * Sets the default settings for all SplitType instances.\n   *\n   * Setting `SplitType.defaults` to an object will merge that object with the\n   * existing defaults.\n   *\n   * @param {Object} settings an object containing the settings to override\n   * @deprecated\n   * @static\n   * @example\n   * SplitType.defaults = { \"position\": \"absolute\" }\n   */\n\n\n  static set defaults(options) {\n    _defaults = extend(_defaults, parseSettings(options));\n  }\n  /**\n   * Sets the default settings for all SplitType instances.\n   * The provided object will be merged with the existing defaults objects.\n   *\n   * @param {Object} settings an object containing the settings to override\n   * @returns {Object} the new default settings\n   * @public\n   * @static\n   * @example\n   * SplitType.setDefaults({ \"position\": \"absolute\" })\n   */\n\n\n  static setDefaults(options) {\n    _defaults = extend(_defaults, parseSettings(options));\n    return defaults;\n  }\n  /**\n   * Revert target elements to their original html content\n   * Has no effect on that\n   *\n   * @param {any} elements The target elements to revert. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @static\n   */\n\n\n  static revert(elements) {\n    getTargetElements(elements).forEach(element => {\n      const {\n        isSplit,\n        html,\n        cssWidth,\n        cssHeight\n      } = get(element);\n\n      if (isSplit) {\n        element.innerHTML = html;\n        element.style.width = cssWidth || '';\n        element.style.height = cssHeight || '';\n        remove(element);\n      }\n    });\n  }\n  /**\n   * Creates a new SplitType instance\n   * This static method provides a way to create a `SplitType` instance without\n   * using the `new` keyword.\n   *\n   * @param {any} target The target elements to split. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @param {Object} [options] Settings for the SplitType instance\n   * @return {SplitType} the SplitType instance\n   * @static\n   */\n\n\n  static create(target, options) {\n    return new SplitType(target, options);\n  }\n  /**\n   * Creates a new `SplitType` instance\n   *\n   * @param {any} elements The target elements to split. One of:\n   *  - {string} A css selector\n   *  - {HTMLElement} A single element\n   * -  {NodeList} A NodeList or collection\n   *  - {HTMLElement[]} An array of Elements\n   * -  {Array<HTMLElement|NodeList|HTMLElement[]>} A nested array of elements\n   * @param {Object} [options] Settings for the SplitType instance\n   */\n\n\n  constructor(elements, options) {\n    this.isSplit = false;\n    this.settings = extend(_defaults, parseSettings(options));\n    this.elements = getTargetElements(elements); // Revert target elements (if they are already split)\n    // Note: we need to call `revert` in the constructor before caching the\n    // original html content of the target elements.\n\n    this.revert(); // Store the original html content of each target element\n\n    this.elements.forEach(element => {\n      set(element, 'html', element.innerHTML);\n    }); // Start the split process\n\n    this.split();\n  }\n  /**\n   * Splits the text in all target elements. This method is called\n   * automatically when a new SplitType instance is created. It can also be\n   * called manually to re-split text with new options.\n   * @param {Object} options\n   * @public\n   */\n\n\n  split(options) {\n    // Revert target elements (if they are already split)\n    // Note: revert was already called once in the constructor. However, we\n    // need to call it again here so text is reverted when the user manually\n    // calls the `split` method to re-split text.\n    this.revert(); // Create arrays to hold the split lines, words, and characters\n\n    this.lines = [];\n    this.words = [];\n    this.chars = []; // cache vertical scroll position before splitting\n\n    const scrollPos = [window.pageXOffset, window.pageYOffset]; // If new options were passed into the `split()` method, update settings\n\n    if (options !== undefined) {\n      this.settings = extend(this.settings, parseSettings(options));\n    }\n\n    const types = parseTypes(this.settings.types); // If the `types` option is set to an empty array, text will not be split.\n    // @example new SplitType('#target', { types: [] })\n\n    if (types.none) {\n      return;\n    } // Split text in each target element\n\n\n    this.elements.forEach(element => {\n      // Add the split text nodes from this element to the arrays of all split\n      // text nodes for this instance.\n      set(element, 'isRoot', true);\n      const {\n        words,\n        chars\n      } = split(element, this.settings);\n      this.words = [...this.words, ...words];\n      this.chars = [...this.chars, ...chars];\n    });\n    this.elements.forEach(element => {\n      if (types.lines || this.settings.absolute) {\n        const lines = repositionAfterSplit(element, this.settings, scrollPos);\n        this.lines = [...this.lines, ...lines];\n      }\n    }); // Set isSplit to true for the SplitType instance\n\n    this.isSplit = true; // Set scroll position to cached value.\n\n    window.scrollTo(scrollPos[0], scrollPos[1]); // Clean up stored data\n\n    cleanup();\n  }\n  /**\n   * Reverts target element(s) back to their original html content\n   * Deletes all stored data associated with the target elements\n   * Resets the properties on the splitType instance\n   *\n   * @public\n   */\n\n\n  revert() {\n    if (this.isSplit) {\n      // Reset instance properties if necessary\n      this.lines = null;\n      this.words = null;\n      this.chars = null;\n      this.isSplit = false;\n    }\n\n    SplitType.revert(this.elements);\n  }\n\n}\n\n\n\n\n//# sourceURL=webpack://webpack-workflow/./node_modules/split-type/dist/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_require__("./src/scripts/app.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/styles/app.scss");
/******/ 	
/******/ })()
;